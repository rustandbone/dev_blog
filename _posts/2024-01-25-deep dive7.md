---
layout: post
title: "모던 JS deep dive 2회차 챕터 15 let, const 키워드와 블록 레벨 스코프"
date: 2024-01-25 18:00:00 +0900
categories: blog JavaScript Modern_JS_deep_dive
published: true
---

# 모던 JS deep dive 2회차

- [모던 JS deep dive 2회차](#모던-js-deep-dive-2회차)
  - [15. let, const 키워드와 블록 레벨 스코프](#15-let-const-키워드와-블록-레벨-스코프)
    - [15.1 var 키워드로 선언한 변수의 문제점](#151-var-키워드로-선언한-변수의-문제점)
    - [15.1.1 변수 중복 선언 허용](#1511-변수-중복-선언-허용)
    - [15.1.2 함수 레벨 스코프](#1512-함수-레벨-스코프)
    - [15.1.3 변수 호이스팅](#1513-변수-호이스팅)
    - [15.2 let 키워드](#152-let-키워드)
    - [15.2.1 변수 중복 선언 금지](#1521-변수-중복-선언-금지)
    - [15.2.2 블록 레벨 스코프](#1522-블록-레벨-스코프)
    - [15.2.3 변수 호이스팅](#1523-변수-호이스팅)
    - [15.3 const 키워드](#153-const-키워드)
    - [15.3.1 선언과 초기화](#1531-선언과-초기화)
    - [15.3.2 재할당](#1532-재할당)
    - [15.3.3 상수](#1533-상수)
    - [15.3.4 const 키워드와 객체](#1534-const-키워드와-객체)

## 15. let, const 키워드와 블록 레벨 스코프

### 15.1 var 키워드로 선언한 변수의 문제점

### 15.1.1 변수 중복 선언 허용

변수를 중복 선언하면 초기화문 유무에 따라 다르게 동작. 초기화문이 있는 변수 선언문은 var 키워드가 없는 것처럼 동작하고 초기화문이 없는 변수 선언문은 무시됨. 에러 발생하지 않음

### 15.1.2 함수 레벨 스코프

var 키워드로 선언한 변수는 오로지 함수의 코드 블록만을 지역 스코프로 인정. 함수 회부에서 var 키워드로 선언한 변수는 코드 블록 내에서 선언해도 모두 전역 변수가 됨.

### 15.1.3 변수 호이스팅

var 키워드로 변수 선언 시, 변수 호이스팅에 의해 변수 선언문이 코드의 선두로 끌려 올려진 것처럼 동작

var 키워드로 선언한 변수는 변수 선언문 이전에 참조 가능. 할당문 이전에 참조 시 언제나 undefined 반환

### 15.2 let 키워드

### 15.2.1 변수 중복 선언 금지

변수 중복 선언 시 문법 에러 발생

### 15.2.2 블록 레벨 스코프

let 키워드로 선언한 변수는 모든 코드 블록(함수, if문, for문, while문, try/catch문 등)을 지역 스코프로 인정하는 블록 레벨 스코프를 따름

### 15.2.3 변수 호이스팅

let 키워드로 선언한 변수는 변수 호이스팅이 발생하지 않는 것처럼 작동.

변수 선언문 이전에 참조하면 참조 에러 발생

var 키워드 선언 변수는 런타임 이전에 선언 단계, 초기화 단계가 한 번에 진행

let 키워드로 선언한 변수는 선언 단계, 초기화 단계가 분리되어 진행. 선언 단계가 먼저 실행되지만, 초기화 단계는 변수 선언문에 도달했을 때 실행됨

초기화 단계 실행 전 변수 접근하려고 하면 참조 에러 발생. 스코프 시작 지점부터 변수 선언문(초기화 단계 시작 지점)까지 변수 참조 불가

일시적 사각지대(TDZ - Temporal Dead Zone) : 스코프의 시작 지점부터 초기화 시작 지점까지 변수를 참조할 수 없는 구간

자바스크립트는 ES6에서 도입된 let, const를 포함한 모든 선언을 호이스팅한다. 하지만, let, const, class를 선언한 선언문은 호이스팅이 발생하지 않는 것처럼 동작함

### 15.3 const 키워드

const 키워드는 상수 선언 위해 사용

### 15.3.1 선언과 초기화

const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화해야 함. 그렇지 않으면 문법 에러 발생

### 15.3.2 재할당

const 키워드로 선언한 변수는 재할당 금지

### 15.3.3 상수

const 키워드로 선언한 변수에 원시 값을 할당한 경우 변수 값 변경 불가.

상수는 재할당이 금지된 변수를 말함.

상수는 상태 유지와 가독성, 유지보수의 편의를 위해 적극 사용해야 함.

const 키워드로 선언된 변수에 원시 값을 할당한 경우 원시 값은 변경할 수 없는 값이고 const 키워드에 의해 재할당 금지되므로 할당된 값을 변경할 수 있는 방법은 없음

상수는 프로그램 전체에서 공통적으로 사용하므로 나중에 변경 시 상수만 변경하면 되기 때문에 유지보수성 대폭 향상

### 15.3.4 const 키워드와 객체

const 키워드로 선언된 변수에 객체를 할당한 경우 값을 변경할 수 있음

변경 가능한 값이 객체는 재할당 없이도 직접 변경이 가능하기 때문

const 키워드는 재할당을 금지할 뿐 "불변"을 의미하지는 않음. 새로운 값을 재할당하는 것은 불가능하지만, 프로퍼티 동적 생성, 삭제, 프로퍼티 값의 변경을 통해 객체를 변경하는 것은 가능.  
객체가 변경되더라도 변수에 할당된 참조 값은 변경되지 않음
